# 21 December 2018

[Programming Languages - Lecture 1](https://www.youtube.com/watch?v=3N__tvmZrzc)

- There are lots of ways to classify programming languages:
  - High vs. low level
  - Functional versus Procedural versus Object-Oriented
  - Textual versus Graphical
  - Compiled versus Interpreted
  - etc.
- But many languages can't be classified neatly.
  - Many languages are multi-paradigm languages
- Science is often the work of classifying things
  - The attempt to classify programming languages is an attempt to make computing
    scientific.
  - Atomic theory:
    - Break something into smaller pieces.
    - Understand the rules for composing the smaller pieces.
  - Classification tries to use the similarity between different things as a way
    of understanding those things
  - Powerful idea:
    - understand the atoms
    - understand the rules of composition for those atoms
- The common classifications for programming languages fail because they are not
  based on understanding the atoms of the language and the rules for composing
  those atoms.
- Focus on the small language inside the large language.
  - Language features desugar to a smaller set of features.
  - "Inside everything large language is a small language"
  - To understand a programming language, try to find the small language inside of 
    it.
  - Examples:
    - Logic
      - All logic gates desugar to the Nan gate
      - All logic gates desugar to the Nor gate
    - Arithmetic
      - All arithmetic operations desugar to looping addition with `-1` or `+1`.
    - All loop constructs desugar to a single loop construct
      - This could be a while loop
- Syntax sugar often desugars in more than one way.
  - Ultimately, there is more than one equivalent computation model: 
    - Turing machine
    - Lambda calculus
- How you desugar is determined by what you want to optimize.
- The challenge is to prove that the desugared syntax is equivalent to the 
  original.
- Recipe for understanding a programming language:
  - Desugar the language features to find smaller, essential language
- Recipe for designing a programming language:
  - Start with a small set of atomic features
  - _Don't_ start with the surface syntax, e.g. braces versus indented is 
    not important.
  - Write an interpreter for that atomic language.
  - Play with the atoms. Try composing them.
  - Refine the core language.
  - Then add the syntax sugar.
  - You could even offer several syntaxes for the same core language 
    (multiple interfaces).

**Reading List**

- ["Epigrams in Programming" by Alan Perlis](http://www.cs.yale.edu/homes/perlis-alan/quotes.html)
